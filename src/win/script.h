/* Do not modify! This code is automatically generated by ../generic/tcldecmt.tcl */
char script_h[] = "\
namespace eval web {}\n\
proc web::putxfile {file {channel \"\"} {vmsg \"\"}} {\n\
if {[string length $vmsg]} {\n\
upvar $vmsg msg\n\
}\n\
if {[string length $channel]} {\n\
if {[web::readfile $channel content msg]} {\n\
return 1\n\
}\n\
return [catch {uplevel [list web::putx $file $content]} msg]\n\
} else {\n\
if {[web::readfile $file content msg]} {\n\
return 1\n\
}\n\
return [catch {uplevel [list web::putx $content]} msg]\n\
}\n\
}\n\
proc web::readfile {name vtarget {vmsg \"\"}} {\n\
upvar $vtarget target\n\
if {[string length $vmsg]} {\n\
upvar $vmsg msg\n\
}\n\
return [catch {\n\
set fh [open $name r]\n\
set target [read $fh]\n\
close $fh\n\
} msg]\n\
}\n\
proc web::include {name {vmsg \"\"}} {\n\
if {[string length $vmsg]} {\n\
upvar $vmsg msg\n\
}\n\
if {![file exists $name]} {\n\
set so \"$name[info sharedlibextension]\"\n\
if {[file exists $so]} {\n\
return [catch {uplevel [list load $so]} msg]\n\
}\n\
}\n\
return [catch {uplevel [list source $name]} msg]\n\
}\n\
proc web::match {res list val} {\n\
if {[lsearch -exact $list $val] >= 0} {\n\
return $res\n\
}\n\
return \"\"\n\
}\n\
proc web::list2uri {list} {\n\
if {[llength $list] % 2} {\n\
error \"list must have even number of elems\"\n\
}\n\
set pairs {}\n\
foreach {k v} $list {\n\
lappend pairs [join [list [uriencode $k] [uriencode $v] ] = ]\n\
}\n\
return [join $pairs &]\n\
}\n\
proc web::uri2list {string} {\n\
set res \"\"\n\
foreach item [split $string &] {\n\
set kv [split $item =]\n\
if [llength $kv] {\n\
lappend res [uridecode [lindex $kv 0]] [uridecode [lindex $kv 1]]\n\
}\n\
}\n\
return $res\n\
}\n\
namespace eval web::ap {}\n\
proc web::ap::perReqInit {} {\n\
web::request -reset\n\
web::response -resetall\n\
web::cmdurlcfg -reset\n\
}\n\
proc web::ap::perReqCleanup {} {\n\
web::logdest delete\n\
web::logfilter delete\n\
}\n\
namespace eval web::cgi {}\n\
proc web::cgi::copyenv {} {\n\
set cgienv {\n\
SERVER_SOFTWARE\n\
SERVER_NAME\n\
GATEWAY_INTERFACE\n\
SERVER_PROTOCOL\n\
SERVER_PORT\n\
REQUEST_METHOD\n\
PATH_INFO\n\
PATH_TRANSLATED\n\
SCRIPT_NAME\n\
QUERY_STRING\n\
REMOTE_HOST\n\
REMOTE_ADDR\n\
AUTH_TYPE\n\
REMOTE_USER\n\
REMOTE_IDENT\n\
CONTENT_TYPE\n\
CONTENT_LENGTH\n\
HTTPS\n\
}\n\
foreach e [array names ::env] {\n\
if {![string match HTTP_* $e]} {\n\
if {[lsearch -exact $cgienv $e] == -1} continue\n\
}\n\
web::request -set $e $::env($e)\n\
}\n\
}\n\
proc web::context {name} {\n\
if {![string match ::* $name]} {\n\
set name [uplevel namespace current]::$name\n\
}\n\
namespace eval $name {\n\
namespace eval vars {\n\
}\n\
proc cset {key value} {\n\
return [set vars::$key $value]\n\
}\n\
proc cappend {key args} {\n\
return [eval append [list vars::$key] $args]\n\
}\n\
proc clappend {key args} {\n\
return [eval lappend [list vars::$key] $args]\n\
}\n\
proc cunset {args} {\n\
if {![llength $args]} {\n\
namespace delete vars\n\
namespace eval vars {}\n\
} else {\n\
foreach key $args {\n\
if {[info exists vars::$key]} {\n\
unset vars::$key\n\
}\n\
}\n\
}\n\
}\n\
proc cget {key {default \"\"}} {\n\
if {[info exists vars::$key]} {\n\
return [set vars::$key]\n\
} else {\n\
return $default\n\
}\n\
}\n\
proc cexists {key} {\n\
return [info exists vars::$key]\n\
}\n\
\n\
proc carray {option arrayName args} {\n\
if {[llength $args]} {\n\
return [array $option vars::$arrayName [lindex $args 0]]\n\
} else {\n\
return [array $option vars::$arrayName]\n\
}\n\
}\n\
proc cnames {{pattern *}} {\n\
set result \"\"\n\
foreach var [info vars [namespace current]::vars::$pattern] {\n\
lappend result [namespace tail $var]\n\
}\n\
return $result\n\
}\n\
proc dump {} {\n\
set result \"\"\n\
foreach var [lsort [cnames]] {\n\
if {[array exists vars::$var]} {\n\
lappend result [list carray set $var [array get vars::$var]]\n\
} else {\n\
lappend result [list cset $var [set vars::$var]]\n\
}\n\
}\n\
return [join $result \\n]\n\
}\n\
proc delete {} {\n\
namespace delete [namespace current]\n\
}\n\
}\n\
}\n\
proc web::sessioncontextfactory {ctxmgrname} {\n\
if {![string match ::* $ctxmgrname]} {\n\
set ctxmgrname [uplevel namespace current]::$ctxmgrname\n\
}\n\
web::context $ctxmgrname\n\
proc ${ctxmgrname}::_parseargs {argList} {\n\
set argc [llength $argList]\n\
for {set i 0} {$i < $argc} {incr i} {\n\
set arg [lindex $argList $i]\n\
set found 0\n\
foreach opt {idgen attachto} {\n\
if {[string equal $arg -$opt]} {\n\
variable _$opt\n\
if {[incr i]>$argc} {\n\
error \"argument -$opt needs a value.\"\n\
}\n\
set _$opt [lindex $argList $i]\n\
set found 1\n\
break\n\
}\n\
}\n\
if {!$found} {\n\
error \"unknown argument $arg.\"\n\
}\n\
}\n\
}\n\
proc ${ctxmgrname}::init {{id \"\"} {create 0}} {\n\
cunset\n\
if {[string length $id]} {\n\
_load $id $create\n\
} else {\n\
variable _attachto\n\
if {![info exists _attachto]} {\n\
error \"no param to get session id from specified. Use -attachto.\"\n\
}\n\
set c [web::param -count $_attachto]\n\
if { $c == 1 } {\n\
set id\n\
_load [web::param $_attachto] $create\n\
} elseif { $c > 1} {\n\
error \"multiple params of \\\"$_attachto\\\"\"\n\
} else {\n\
new\n\
}\n\
}\n\
}\n\
proc ${ctxmgrname}::new {{id \"\"}} {\n\
cunset\n\
variable _id\n\
if {[string length $id]} {\n\
set _id $id\n\
} else {\n\
variable _idgen\n\
if {![info exists _idgen]} {\n\
error \"no idgen for new session id. Use -idgen.\"\n\
}\n\
set _id [eval $_idgen]\n\
}\n\
commit\n\
}\n\
proc ${ctxmgrname}::commit {} {\n\
variable _id\n\
variable _attachto\n\
if {[info exists _id]} {\n\
save $_id\n\
} else {\n\
error \"no context to commit.\"\n\
}\n\
if { [info exists _attachto] } {\n\
web::cmdurlcfg -set $_attachto $_id\n\
}\n\
}\n\
proc ${ctxmgrname}::id {} {\n\
variable _id\n\
if {[info exists _id]} {\n\
return $_id\n\
} else {\n\
error \"no current id.\"\n\
}\n\
}\n\
proc ${ctxmgrname}::_load {id {create 0}} {\n\
variable _id\n\
load $id $create\n\
set _id $id\n\
}\n\
proc ${ctxmgrname}::load {id {create 0}} {\n\
error \"no load method defined.\"\n\
}\n\
proc ${ctxmgrname}::save {id} {\n\
error \"no save method defined.\"\n\
}\n\
proc ${ctxmgrname}::invalidate {} {\n\
error \"no invalidate method defined.\"\n\
}\n\
}\n\
proc web::filecontext {ctxmgrname args} {\n\
if {![string match ::* $ctxmgrname]} {\n\
set ctxmgrname [uplevel namespace current]::$ctxmgrname\n\
}\n\
web::sessioncontextfactory $ctxmgrname\n\
namespace eval ::$ctxmgrname {\n\
variable _perm 0666\n\
variable _crypt 1\n\
}\n\
set argc [llength $args]\n\
set baseargs {}\n\
for {set i 0} {$i < $argc} {incr i} {\n\
set arg [lindex $args $i]\n\
set found 0\n\
foreach opt {path perm crypt} {\n\
if {[string equal $arg -$opt]} {\n\
if {[incr i]>$argc} {\n\
error \"argument -$opt needs a value.\"\n\
}\n\
set ${ctxmgrname}::_$opt [lindex $args $i]\n\
set found 1\n\
break\n\
}\n\
}\n\
if {!$found} {\n\
lappend baseargs $arg\n\
}\n\
}\n\
if {[info exists ${ctxmgrname}::_path] == 0} {\n\
error \"web::filecontext requires a -path argument. Use '-path %d' if you would like to keep the default behavior.\"\n\
}\n\
${ctxmgrname}::_parseargs $baseargs\n\
proc ${ctxmgrname}::_checkID {id} {\n\
set notok 0\n\
if { [string compare [file dirname $id] \".\"] != 0 } {\n\
set notok 1\n\
} elseif {[string match \"\\.*\" $id] == 1} {\n\
set notok 1\n\
} elseif {[regexp {^[a-zA-Z0-9\\._\\-]+$} $id] == 0} {\n\
set notok 1\n\
}\n\
if {$notok} {\n\
error \"id \\\"$id\\\" is not safe, rejected.\"\n\
}\n\
return\n\
}\n\
proc ${ctxmgrname}::load {id {create 0}} {\n\
set filename [_getFileName $id]\n\
if { [string equal $create \"-create\"] } {\n\
set fh [open $filename {RDWR CREAT}]\n\
} else {\n\
set fh [open $filename {RDWR}]\n\
}\n\
web::lockfile $fh\n\
if {[catch {\n\
variable _crypt\n\
if {$_crypt} {\n\
namespace eval [namespace current] [web::decrypt [read $fh]]\n\
} else {\n\
namespace eval [namespace current] [read $fh]\n\
}\n\
} msg]} {\n\
web::unlockfile $fh\n\
close $fh\n\
error $msg\n\
}\n\
web::unlockfile $fh\n\
close $fh\n\
}\n\
proc ${ctxmgrname}::save {id} {\n\
variable _perm\n\
set filename [_getFileName $id]\n\
set fh [open $filename {CREAT WRONLY} $_perm]\n\
web::lockfile $fh\n\
web::truncatefile $fh\n\
seek $fh 0 start\n\
if {[catch {\n\
variable _crypt\n\
if {$_crypt} {\n\
puts -nonewline $fh [web::encrypt [dump]]\n\
} else {\n\
puts $fh [dump]\n\
}\n\
} msg]} {\n\
web::unlockfile $fh\n\
close $fh\n\
error $msg\n\
}\n\
web::unlockfile $fh\n\
close $fh\n\
}\n\
proc ${ctxmgrname}::invalidate {} {\n\
variable _perm\n\
cunset\n\
set filename [_getFileName [id]]\n\
file delete -force $filename\n\
}\n\
proc ${ctxmgrname}::_getFileName {id} {\n\
variable _path\n\
_checkID $id\n\
return [format $_path $id]\n\
}\n\
}\n\
proc web::cookiecontext {ctxmgrname args} {\n\
if {![string match ::* $ctxmgrname]} {\n\
set ctxmgrname [uplevel namespace current]::$ctxmgrname\n\
}\n\
web::sessioncontextfactory $ctxmgrname\n\
\n\
namespace eval $ctxmgrname {\n\
variable _channel \"\"\n\
variable _domain \"\"\n\
variable _path \"\"\n\
variable _expires \"day\"\n\
variable _crypt 1\n\
variable _secure 0\n\
}\n\
set argc [llength $args]\n\
set baseargs {}\n\
for {set i 0} {$i < $argc} {incr i} {\n\
set arg [lindex $args $i]\n\
set found 0\n\
foreach opt {channel domain path expires secure crypt} {\n\
if {[string equal $arg -$opt]} {\n\
if {[incr i]>$argc} {\n\
error \"argument -$opt needs a value.\"\n\
}\n\
set ${ctxmgrname}::_$opt [lindex $args $i]\n\
set found 1\n\
break\n\
}\n\
}\n\
if {!$found} {\n\
lappend baseargs $arg\n\
}\n\
}\n\
${ctxmgrname}::_parseargs $baseargs\n\
proc ${ctxmgrname}::_getCookie {id} {\n\
::set cookie [web::request HTTP_COOKIE]\n\
foreach v [split $cookie \"=;\"] {\n\
lappend kvlist [string trim $v]\n\
}\n\
foreach {key value} $kvlist {\n\
if {[string compare $key $id] == 0} {\n\
return $value\n\
}\n\
}\n\
error \"no matching cookie found\"\n\
}\n\
proc ${ctxmgrname}::init {id {create 0}} {\n\
cunset\n\
if { [catch {_load $id $create}]} {\n\
new $id\n\
}\n\
}\n\
proc ${ctxmgrname}::load {id {create 0}} {\n\
variable _crypt\n\
variable _id\n\
if {$_crypt} {\n\
namespace eval [namespace current] [web::decrypt [_getCookie $id]]\n\
} else {\n\
namespace eval [namespace current] [web::uridecode [_getCookie $id]]\n\
}\n\
set _id $id\n\
}\n\
proc ${ctxmgrname}::save {id {doInvalidate 0}} {\n\
variable _channel\n\
variable _domain\n\
variable _path\n\
variable _expires\n\
variable _secure\n\
set ochannel [web::response]\n\
if {[string length $_channel]} {\n\
web::response -select $_channel\n\
}\n\
if {[web::response -sendheader] == 0} {\n\
web::log ws3.error \"web::cookiecontext::commit: commit too late, header already sent\"\n\
if {![info exists ochannel]} {\n\
web::response -select $ochannel\n\
}\n\
error \"cookie commit too late (header already sent)\"\n\
}\n\
variable _crypt\n\
if {$_crypt} {\n\
set data [web::encrypt [dump]]\n\
} else {\n\
set data [web::uriencode [dump]]\n\
}\n\
set cookie \"$id=$data\"\n\
if { $doInvalidate } {\n\
append cookie \"; expires=Sat, 01-01-2000 00:00:00 MET\"\n\
} else {\n\
if { $data == \"{}\" || $data == \"\"} {\n\
set cookie \"$id=; expires=Sat, 01-01-2000 00:00:00 MET\"\n\
} else {\n\
set expsec [clock seconds]\n\
if {[regexp {^[0-9]+$} $_expires]} {\n\
set expsec $_expires\n\
} else {\n\
if {[string equal $_expires \"day\"]} {\n\
incr expsec 86400\n\
} elseif { [string equal $_expires \"week\"] } {\n\
incr expsec 604800\n\
}\n\
}\n\
if { [catch {clock scan $_expires} msg] } {\n\
\n\
set expstr $_expires\n\
} else {\n\
\n\
if {[string equal $_expires \"today\"]} {\n\
set expstr $_expires\n\
} else {\n\
set expstr [clock format $expsec -format \"%a, %d-%m-%Y %H:%M:%S %Z\"]\n\
}\n\
}\n\
if { [string length $expstr] } {\n\
append cookie \"; expires=$expstr\"\n\
}\n\
}\n\
}\n\
if {[string length $_path]} {\n\
append cookie \"; path=$_path\"\n\
}\n\
if {[string length $_domain]} {\n\
append cookie \"; domain=$_domain\"\n\
}\n\
if {$_secure} {\n\
append cookie \"; secure\"\n\
}\n\
web::response -set Set-Cookie $cookie\n\
if {![info exists ochannel]} {\n\
web::response -select $ochannel\n\
}\n\
}\n\
proc ${ctxmgrname}::invalidate {} {\n\
\n\
cunset\n\
\n\
save [id] 1\n\
}\n\
}\n\
";
